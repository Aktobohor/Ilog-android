package it.unitn.disi.witmee.sensorlog.runnables;

import android.Manifest;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.location.LocationListener;
import android.location.LocationManager;
import android.util.Log;

import it.unitn.disi.witmee.sensorlog.application.iLogApplication;
import it.unitn.disi.witmee.sensorlog.broadcastreceivers.AudioRemoveBroadcastReceiver;
import it.unitn.disi.witmee.sensorlog.broadcastreceivers.AudioRequestBroadcastReceiver;
import it.unitn.disi.witmee.sensorlog.broadcastreceivers.LocationGPSRemoveBroadcastReceiver;
import it.unitn.disi.witmee.sensorlog.broadcastreceivers.LocationGPSRequestBroadcastReceiver;
import it.unitn.disi.witmee.sensorlog.broadcastreceivers.LocationGPSListener;
import it.unitn.disi.witmee.sensorlog.broadcastreceivers.LocationPassiveGPSListener;
import it.unitn.disi.witmee.sensorlog.model.audio.AU;
import it.unitn.disi.witmee.sensorlog.model.metalog.SM;
import it.unitn.disi.witmee.sensorlog.model.system.ST;
import it.unitn.disi.witmee.sensorlog.utils.Utils;

/**
 * Class that implements a {@link Runnable} that manages the data collection of the {@link it.unitn.disi.witmee.sensorlog.model.locations.GL} event. The data
 * collection occurs through two {@link LocationListener}, {@link #gpsLocationListener} and {@link #passiveLocationListener}.
 * They are registered/unregistered in this class and the data of type {@link it.unitn.disi.witmee.sensorlog.model.locations.GL} and  event is generated in them.
 * It instantiates a {@link LocationManager} object that request location updates through the method {@link LocationManager#requestLocationUpdates}. This process is repeated
 * using an {@link AlarmManager} in combination with two {@link PendingIntent}, {@link #pendingIntentRequest} and {@link #pendingIntentRemove}
 * that schedule the operation at fixed time intervals. The reason for the two {@link PendingIntent} and {@link android.content.BroadcastReceiver} is that this Runnable
 * needs to trigger the event of start collecting the position and, after some seconds, stop it. The main reason for this behavior is to save battery.
 * @author Mattia Zeni
 */
public class LocationGPSRunnable implements Runnable {

    private volatile boolean isStopped = false;
    private static int SENSOR_ID = iLogApplication.GPS_ID;
    private static LocationManager locationManager = null;
    private static LocationListener gpsLocationListener = null;
    private static LocationListener passiveLocationListener = null;
    private static boolean locationRequested = false;
    public static AlarmManager alarmManager;
    public static PendingIntent pendingIntentRequest = null;
    public static PendingIntent pendingIntentRemove = null;

    /**
     * Method that starts the collection of the {@link it.unitn.disi.witmee.sensorlog.model.locations.GL} events. It performs the following operations:
     * <ul>
     *     <li>Starts the {@link it.unitn.disi.witmee.sensorlog.services.LoggingMonitoringService} if not already running using the {@link iLogApplication#startLoggingMonitoringService()}</li>
     *     <li>Persists a {@link SM} event that indicates that the sensor just started collecting data</li>
     *     <li>Updates the {@link iLogApplication#sensorLoggingState} variable to indicate that the sensor is running</li>
     *     <li>Persists a {@link ST} event that indicates that this runnable has been started</li>
     *     <li>Initializes the {@link #locationManager}</li>
     *     <li>Initializes the {@link #pendingIntentRequest} that runs the {@link LocationGPSRequestBroadcastReceiver} class</li>
     *     <li>Initializes the {@link #pendingIntentRemove} that runs the {@link LocationGPSRemoveBroadcastReceiver} class</li>
     *     <li>Starts the collection process by calling the methods {@link #requestLocationUpdates()} and {@link #requestPassiveLocationUpdates}</li>
     * </ul>
     * There are two types of location collected by this class, {@link LocationManager#PASSIVE_PROVIDER} and {@link LocationManager#GPS_PROVIDER}. The latter is the very accurate
     * one obtained by the GPS sensor embedded in the device while the former allows to collect all the locations tha Android system sends to the app, e.g., when another application
     * is using the localization. Listening to {@link LocationManager#PASSIVE_PROVIDER} location updates, we can collect all the positions generated by other applications like
     * Google Maps, among others, without consuming additional battery.
     */
    public void run() {
        if(iLogApplication.sensorLoggingState.get(SENSOR_ID) != null) {
            isStopped = false;

            System.out.println(!iLogApplication.sensorLoggingState.get(SENSOR_ID) +" "+ iLogApplication.hasSinglePermission(Manifest.permission.ACCESS_FINE_LOCATION));

            if(!iLogApplication.sensorLoggingState.get(SENSOR_ID) && iLogApplication.hasSinglePermission(Manifest.permission.ACCESS_FINE_LOCATION)) {

                iLogApplication.startLoggingMonitoringService();
                Log.d(this.getClass().getSimpleName(), "Start");

                iLogApplication.persistInMemoryEvent(new SM(SENSOR_ID, System.currentTimeMillis(), true));
                iLogApplication.sensorLoggingState.put(SENSOR_ID, true);
                iLogApplication.persistInMemoryEvent(new ST(ST.EVENT_SERVICE_STARTED, this.getClass().getSimpleName()));

                locationManager = (LocationManager) iLogApplication.getAppContext().getApplicationContext().getSystemService(Context.LOCATION_SERVICE);

                pendingIntentRequest = PendingIntent.getBroadcast(
                        iLogApplication.getAppContext(),
                        0, // id, optional
                        new Intent(iLogApplication.getAppContext(), LocationGPSRequestBroadcastReceiver.class), // intent to launch
                        PendingIntent.FLAG_CANCEL_CURRENT);

                pendingIntentRemove = PendingIntent.getBroadcast(
                        iLogApplication.getAppContext(),
                        0, // id, optional
                        new Intent(iLogApplication.getAppContext(), LocationGPSRemoveBroadcastReceiver.class), // intent to launch
                        PendingIntent.FLAG_CANCEL_CURRENT);

                requestLocationUpdates();
                requestPassiveLocationUpdates();
            }
        }
    }

    /**
     * Method used to stop receiving location updates. It cancels the {@link #pendingIntentRequest} and {@link #pendingIntentRemove} in the {@link #alarmManager}.
     */
    public static void locationReceived() {
        removeLocationUpdates();

        if(alarmManager!=null && pendingIntentRemove!=null) {
            alarmManager.cancel(pendingIntentRemove);
        }

        if(alarmManager!=null && pendingIntentRequest!=null) {
            alarmManager.cancel(pendingIntentRequest);
        }

        startRequest();
    }

    /**
     * Method used to request location updates of type {@link LocationManager#GPS_PROVIDER} that, whenever available, are sent to {@link #gpsLocationListener}. Immediately
     * after the registration of the updates, the method calls {@link #startRemove()} to schedule the operation of stopping the location updates.
     */
    public static void requestLocationUpdates() {
        Log.d(iLogApplication.getAppContext().toString(), "Update create gps");

        if(!locationRequested) {
            gpsLocationListener = new LocationGPSListener();
            locationManager = (LocationManager) iLogApplication.getAppContext().getApplicationContext().getSystemService(Context.LOCATION_SERVICE);
            locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, gpsLocationListener);
            locationRequested = true;

            startRemove();
        }
    }

    /**
     * Method used to remove updates from the GPS using {@link android.location.LocationManager#removeUpdates(PendingIntent)} on the {@link #gpsLocationListener}
     */
    public static void removeLocationUpdates() {
        Log.d(iLogApplication.getAppContext().toString(), "Update remove gps");
        if(locationRequested && locationManager!=null) {
            locationManager.removeUpdates(gpsLocationListener);
            locationRequested=false;
        }
    }

    /**
     * Method used to request location updates of type {@link LocationManager#PASSIVE_PROVIDER} that, whenever available, are sent to {@link #passiveLocationListener}. In this
     * case we do not start removing the updates as in {@link #requestLocationUpdates} because we keep updates {@link LocationManager#PASSIVE_PROVIDER} always running since
     * they do not involve additional battery consumption.
     */
    public static void requestPassiveLocationUpdates() {
        Log.d(iLogApplication.getAppContext().toString(), "Update create passive gps");
        passiveLocationListener = new LocationPassiveGPSListener();
        locationManager = (LocationManager) iLogApplication.getAppContext().getApplicationContext().getSystemService(Context.LOCATION_SERVICE);
        locationManager.requestLocationUpdates(LocationManager.PASSIVE_PROVIDER, 0, 0, passiveLocationListener);
    }

    /**
     * Method used to remove updates from the GPS using {@link android.location.LocationManager#removeUpdates(PendingIntent)} on the {@link #passiveLocationListener}
     */
    public static void removePassiveLocationUpdates() {
        Log.d(iLogApplication.getAppContext().toString(), "Update remove passive gps");
        if(locationManager!=null && passiveLocationListener!=null) {
            locationManager.removeUpdates(passiveLocationListener);
        }
    }

    /**
     * Contains information about the status of the data collection for this {@link it.unitn.disi.witmee.sensorlog.model.system.AM} event
     * @return true if the data collection is stopped, false otherwise
     */
    public boolean isStopped() {
        return isStopped;
    }

    /**
     * Method that updates the status of the Runnable and cancels the {@link PendingIntent} {@link #pendingIntentRequest} and {@link #pendingIntentRemove} form the
     * {@link #alarmManager}
     * @param isStop boolean value that identifies the status, true if the data collection is stopped, false otherwise
     */
    private void setStopped(boolean isStop) {
        if (isStopped != isStop)
            isStopped = isStop;

        if(alarmManager!=null && pendingIntentRemove!=null) {
            alarmManager.cancel(pendingIntentRemove);
        }

        if(alarmManager!=null && pendingIntentRequest!=null) {
            alarmManager.cancel(pendingIntentRequest);
        }

        iLogApplication.stopLoggingMonitoringService();
    }

    /**
     * Method that stops the collection of the {@link it.unitn.disi.witmee.sensorlog.model.locations.GL} events. It performs the following operations:
     * <ul>
     *     <li>Removes the updates by calling {@link #removeLocationUpdates()} and {@link #removePassiveLocationUpdates()}</li>
     *     <li>Persists a {@link SM} event that indicates that the sensor just stopped collecting data</li>
     *     <li>Persists a {@link ST} event that indicates that this runnable has been stopped</li>
     *     <li>Updates the {@link iLogApplication#sensorLoggingState} variable to indicate that the sensor is stopped</li>
     *     <li>Sets this runnable as stopped</li>
     * </ul>
     */
    public void stop() {
        if(iLogApplication.sensorLoggingState.get(SENSOR_ID) != null) {
            if(!isStopped() && locationManager!=null && gpsLocationListener!=null) {
                removeLocationUpdates();
            }

            if(!isStopped() && locationManager!=null && passiveLocationListener!=null) {
                removePassiveLocationUpdates();
            }

            iLogApplication.persistInMemoryEvent(new SM(SENSOR_ID, System.currentTimeMillis(), false));
            iLogApplication.persistInMemoryEvent(new ST(ST.EVENT_SERVICE_STOPPED, this.getClass().getSimpleName()));
            iLogApplication.sensorLoggingState.put(SENSOR_ID, false);
            Log.d(this.getClass().getSimpleName(), "Stop");

            setStopped(true);
        }
    }

    /**
     * Method that restarts the collection of the {@link it.unitn.disi.witmee.sensorlog.model.locations.GL} events. It performs the following operations:
     * <ul>
     *     <li>Removes location updates by calling {@link #removeLocationUpdates()} and {@link #removePassiveLocationUpdates()}</li>
     *     <li>Requires location updates by calling {@link #requestLocationUpdates()} and {@link #requestPassiveLocationUpdates()}</li>
     * </ul>
     */
    public void restart() {
        if(iLogApplication.sensorLoggingState.get(SENSOR_ID) != null) {
            locationManager = (LocationManager) iLogApplication.getAppContext().getApplicationContext().getSystemService(Context.LOCATION_SERVICE);
            if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) && !iLogApplication.isNetworkConnected() && iLogApplication.hasSinglePermission(Manifest.permission.ACCESS_FINE_LOCATION)) {
                if(!isStopped()) {
                    if(locationManager!=null && gpsLocationListener!=null) {
                        removeLocationUpdates();
                    }
                    if(locationManager!=null && passiveLocationListener!=null) {
                        removePassiveLocationUpdates();
                    }

                    iLogApplication.sensorLoggingState.put(SENSOR_ID, true);

                    locationManager = (LocationManager) iLogApplication.getAppContext().getApplicationContext().getSystemService(Context.LOCATION_SERVICE);

                    gpsLocationListener = new LocationGPSListener();
                    requestLocationUpdates();

                    passiveLocationListener = new LocationPassiveGPSListener();
                    requestPassiveLocationUpdates();
                }
            }
        }
    }

    /**
     * Method that tells the {@link #alarmManager} to execute the {@link #pendingIntentRemove} that runs the {@link LocationGPSRemoveBroadcastReceiver} class. This class
     * stops collecting location information. The {@link #pendingIntentRemove} is executed 20*1000 seconds after the {@link #pendingIntentRequest}, meaning
     * that collects location updates for that amount of time. TODO - Use a variable like in the other Runnables as time interval, remove the 20*1000 hardcoded time interval
     */
    public static void startRemove() {
        if(pendingIntentRemove!=null) {
            alarmManager = (AlarmManager) iLogApplication.getAppContext().getSystemService(Context.ALARM_SERVICE);
            alarmManager.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 20*1000, pendingIntentRemove);
        }
    }

    /**
     * Method that tells the {@link #alarmManager} to execute the {@link #pendingIntentRequest} that runs the {@link LocationGPSRequestBroadcastReceiver} class. This class
     * starts collecting location information. The {@link #pendingIntentRequest} is executed X seconds after the {@link #pendingIntentRequest},
     * meaning that scans for devices for X seconds. The amount of seconds is store in the {@link android.content.SharedPreferences} of the application with the key
     * {@link Utils#CONFIG_LOCATIONCOLLECTIONFREQUENCY}.
     */
    public static void startRequest() {
        if(pendingIntentRequest!=null) {
            alarmManager = (AlarmManager) iLogApplication.getAppContext().getSystemService(Context.ALARM_SERVICE);
            alarmManager.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + iLogApplication.sharedPreferences.getInt(Utils.CONFIG_LOCATIONCOLLECTIONFREQUENCY, 0), pendingIntentRequest);
        }
    }
}
